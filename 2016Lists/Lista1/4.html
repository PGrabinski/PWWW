<!DOCTYPE html>
<html lang="pl">
  <head>
    <meta charset="utf-8">
    <title>Lista 1: Ćwiczenie 4</title>
    <style>
      img {
        width: 300px;
        height: 200px;
        float: left;
        margin-right: 10px
      }
      h1 {
        color: red;
      }
      p{
        color: blue;
        margin: 20px;
      }
    </style>
  </head>
  <ul>
    <li><a href="1.html">Ćwiczenie 1</a></li>
    <li><a href="2.html">Ćwiczenie 2</a></li>
    <li><a href="3.html">Ćwiczenie 3</a></li>
    <li><a href="4.html">Ćwiczenie 4</a></li>
    <li><a href="5.html">Ćwiczenie 5</a></li>
    <li><a href="6.html">Ćwiczenie 6</a></li>
    <li><a href="7.html">Ćwiczenie 7</a></li>
    <li><a href="8.html">Ćwiczenie 8</a></li>
    <li><a href="9.html">Ćwiczenie 9</a></li>
    <li><a href="10.html">Ćwiczenie 10</a></li>
  </ul>
  <body><h1>Tytuł dzieła</h1>
  <img src="https://www.w3resource.com/w3r_images/bubble-short.png" alt="Bubble sort">
  <p>Analysis of algorithms is the branch of computer science that studies the performance of
algorithms, especially their run time and space requirements. See http://en.wikipedia.
org/wiki/Analysis_of_algorithms .
The practical goal of algorithm analysis is to predict the performance of different algo-
rithms in order to guide design decisions.
During the 2008 United States Presidential Campaign, candidate Barack Obama was asked
to perform an impromptu analysis when he visited Google. Chief executive Eric Schmidt
jokingly asked him for “the most efficient way to sort a million 32-bit integers.” Obama
had apparently been tipped off, because he quickly replied, “I think the bubble sort would
be the wrong way to go.” See <a href="http://www.youtube.com/watch?v=k4RRi_ntQc8">bubble sort video</a>.</p>
  <h2>Rozdział 1</h2>
  <p>The relative performance of the algorithms might depend on characteristics of the
hardware, so one algorithm might be faster on Machine A, another on Machine B.
The general solution to this problem is to specify a machine model and analyze the
number of steps, or operations, an algorithm requires under a given model.</p>
  <h3>Sekcja 1</h3>
  <p>Relative performance might depend on the details of the dataset. For example, some
sorting algorithms run faster if the data are already partially sorted; other algorithms
run slower in this case. A common way to avoid this problem is to analyze the worst
case scenario. It is also sometimes useful to analyze average case performance, but it
is usually harder, and sometimes it is not clear what set of cases to average over.</p>
  <h3>Sekcja 2</h3>
  <p>Relative performance also depends on the size of the problem. A sorting algorithm
that is fast for small lists might be slow for long lists. The usual solution to this
problem is to express run time (or number of operations) as a function of problem
size, and to compare the functions asymptotically as the problem size increases.</p>
  <h2>Rozdział 2</h2>
  <p>The good thing about this kind of comparison that it lends itself to simple classification of
algorithms. For example, if I know that the run time of Algorithm A tends to be propor-
tional to the size of the input, n, and Algorithm B tends to be proportional to n 2 , then I
expect A to be faster than B for large values of n.</p>
  <h3>Sekcja 1</h3>
  <p>Suppose you have analyzed two algorithms and expressed their run times in terms of the
size of the input: Algorithm A takes 100n + 1 steps to solve a problem with size n; Algo-
rithm B takes n 2 + n + 1 steps.</p>
  <h3>Sekcja 2</h3>
  <p>The fundamental reason is that for large values of n, any function that contains an n 2 term
will grow faster than a function whose leading term is n. The leading term is the term with
the highest exponent.</p>
  </body>
</html>
